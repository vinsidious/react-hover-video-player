{
  "version": 3,
  "sources": ["../src/HoverVideoPlayer.tsx", "../src/HoverVideoPlayer.styles.ts"],
  "sourcesContent": ["import React, {\n  useRef,\n  useImperativeHandle,\n  useEffect,\n  useState,\n  useCallback,\n} from \"react\";\nimport ReactPlayer from \"react-player/youtube\";\n\nimport {\n  expandToFillContainerStyle,\n  containerSizingStyles,\n  pausedOverlayWrapperSizingStyles,\n  videoSizingStyles,\n  visibleOverlayStyles,\n  hiddenOverlayStyles,\n  overlayTransitionDurationVar,\n} from \"./HoverVideoPlayer.styles\";\n\nimport { HoverVideoPlayerProps } from \"./HoverVideoPlayer.types\";\n\nconst isYouTubeUrl = (url: string) => {\n  return url.match(/^(https?:\\/\\/)?(www\\.)?(youtube\\.com|youtu\\.?be)\\/.+$/);\n};\n\n/**\n * @component HoverVideoPlayer\n * @license MIT\n *\n * @param {HoverVideoPlayerProps} props\n */\nexport default function HoverVideoPlayer({\n  videoSrc,\n  videoCaptions = null,\n  focused = false,\n  disableDefaultEventHandling = false,\n  hoverTarget = null,\n  onHoverStart = null,\n  onHoverEnd = null,\n  hoverOverlay = null,\n  pausedOverlay = null,\n  loadingOverlay = null,\n  loadingStateTimeout = 200,\n  overlayTransitionDuration = 400,\n  playbackStartDelay = 0,\n  restartOnPaused = false,\n  unloadVideoOnPaused = false,\n  playbackRangeStart = null,\n  playbackRangeEnd = null,\n  muted = true,\n  volume = 1,\n  loop = true,\n  preload = undefined,\n  crossOrigin = undefined,\n  controls = false,\n  controlsList = undefined,\n  disableRemotePlayback = true,\n  disablePictureInPicture = true,\n  style = undefined,\n  hoverOverlayWrapperClassName = undefined,\n  hoverOverlayWrapperStyle = undefined,\n  pausedOverlayWrapperClassName = undefined,\n  pausedOverlayWrapperStyle = undefined,\n  loadingOverlayWrapperClassName = undefined,\n  loadingOverlayWrapperStyle = undefined,\n  videoId = undefined,\n  videoClassName = undefined,\n  videoRef: forwardedVideoRef = null,\n  videoStyle = undefined,\n  sizingMode = \"video\",\n  ...spreadableProps\n}: HoverVideoPlayerProps): JSX.Element {\n  // Element refs\n  const containerRef = useRef<HTMLDivElement>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const playerRef = useRef<ReactPlayer>(null);\n  // Forward out local videoRef along to the videoRef prop\n  useImperativeHandle(\n    forwardedVideoRef,\n    () => videoRef.current as HTMLVideoElement\n  );\n\n  const isYouTube = typeof videoSrc === \"string\" && isYouTubeUrl(videoSrc);\n\n  // Effects set attributes on the video which can't be done via props\n  useEffect(() => {\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    if (videoRef.current) videoRef.current.muted = muted;\n  }, [muted]);\n  useEffect(() => {\n    // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n    if (videoRef.current) videoRef.current.volume = volume;\n  }, [volume]);\n  // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n  // via the video element's props, so we have to manually set them in an effect\n  useEffect(() => {\n    if (videoRef.current)\n      videoRef.current.disableRemotePlayback = disableRemotePlayback;\n  }, [disableRemotePlayback]);\n  useEffect(() => {\n    if (videoRef.current)\n      videoRef.current.disablePictureInPicture = disablePictureInPicture;\n  }, [disablePictureInPicture]);\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    if (videoElement && playbackRangeStart) {\n      videoElement.currentTime = playbackRangeStart;\n    }\n  }, [playbackRangeStart]);\n\n  const [hoverTargetElement, setHoverTargetElement] = useState<Node | null>(\n    null\n  );\n\n  useEffect(() => {\n    // Default to the container element unless a hoverTarget prop is provided\n    let element: Node | null = containerRef.current;\n\n    if (hoverTarget) {\n      // Get the hover target element from the hoverTarget prop, or default to the component's container div\n      // A `hoverTarget` value could be a function, a DOM element, or a React ref, so\n      // figure out which one it is and get the hover target element out of it accordingly\n      if (typeof hoverTarget === \"function\") {\n        element = hoverTarget();\n      } else if (hoverTarget instanceof Node) {\n        element = hoverTarget;\n      } else if (hoverTarget && hoverTarget.hasOwnProperty(\"current\")) {\n        element = hoverTarget.current;\n      } else {\n        console.error(\n          \"HoverVideoPlayer was unable to get a usable hover target element. Please check your usage of the `hoverTarget` prop.\"\n        );\n      }\n    }\n\n    setHoverTargetElement(element);\n  }, [hoverTarget]);\n\n  // Keep a ref for the time which the video should be started from next time it is played\n  // This is useful if the video gets unloaded and we want to restore it to the time it was\n  // at before if the user tries playing it again\n  const nextVideoStartTimeRef = useRef<number | null>(null);\n\n  // Whether the user is hovering over the hover target, meaning we should be trying to play the video\n  const [isHovering, setIsHovering] = useState(false);\n  // Whether the video is currently in a loading state, meaning it's not ready to be played yet\n  const [isLoading, setIsLoading] = useState(false);\n  // Whether the video is currently playing or not\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  const isHoveringRef = useRef<boolean>();\n  isHoveringRef.current = isHovering;\n\n  const playTimeoutRef = useRef<number | undefined>();\n  const pauseTimeoutRef = useRef<number | undefined>();\n\n  const cancelTimeouts = useCallback(() => {\n    // Cancel any previously active pause or playback attempts\n    window.clearTimeout(playTimeoutRef.current);\n    window.clearTimeout(pauseTimeoutRef.current);\n  }, []);\n\n  const hasPausedOverlay = Boolean(pausedOverlay);\n  const hasHoverOverlay = Boolean(hoverOverlay);\n\n  // If we have a paused or hover overlay, the player should wait\n  // for the overlay(s) to finish transitioning back in before we\n  // pause the video\n  const shouldWaitForOverlayTransitionBeforePausing =\n    hasPausedOverlay || hasHoverOverlay;\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    if (!hoverTargetElement || !videoElement) return undefined;\n\n    const onHoverStart = () => {\n      // Bail out if we're already hovering\n      if (isHoveringRef.current) return;\n\n      // Cancel any previously active pause or playback attempts\n      cancelTimeouts();\n\n      setIsHovering(true);\n    };\n    const onHoverEnd = () => {\n      cancelTimeouts();\n\n      setIsHovering(false);\n    };\n\n    hoverTargetElement.addEventListener(\"hvp:hoverStart\", onHoverStart);\n    hoverTargetElement.addEventListener(\"hvp:hoverEnd\", onHoverEnd);\n\n    return () => {\n      hoverTargetElement.removeEventListener(\"hvp:hoverStart\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"hvp:hoverEnd\", onHoverEnd);\n    };\n  }, [\n    cancelTimeouts,\n    hoverTargetElement,\n    overlayTransitionDuration,\n    playbackRangeStart,\n    restartOnPaused,\n    shouldWaitForOverlayTransitionBeforePausing,\n  ]);\n\n  const playVideo = useCallback(() => {\n    if (isYouTube) {\n      playerRef.current?.seekTo(playbackRangeStart || 0);\n      playerRef.current?.getInternalPlayer().playVideo();\n    } else {\n      const videoElement = videoRef.current;\n      if (!videoElement) return;\n\n      videoElement.play().catch((error: DOMException) => {\n        // Suppress logging for \"AbortError\" errors, which are thrown when the video is paused while it was trying to play.\n        // These errors are expected and happen often, so they can be safely ignored.\n        if (error.name === \"AbortError\") {\n          return;\n        }\n\n        // Additional handling for when browsers block playback for unmuted videos.\n        // This is unfortunately necessary because most modern browsers do not allow playing videos with audio\n        //  until the user has \"interacted\" with the page by clicking somewhere at least once; mouseenter events\n        //  don't count.\n        // If the video isn't muted and playback failed with a `NotAllowedError`, this means the browser blocked\n        // playing the video because the user hasn't clicked anywhere on the page yet.\n        if (!videoElement.muted && error.name === \"NotAllowedError\") {\n          console.warn(\n            \"HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.\"\n          );\n          // Mute the video and attempt to play again\n          videoElement.muted = true;\n          playVideo();\n\n          // When the user clicks on the document, unmute the video since we should now\n          // be free to play audio\n          const onClickDocument = () => {\n            videoElement.muted = false;\n\n            // Clean up the event listener so it is only fired once\n            document.removeEventListener(\"click\", onClickDocument);\n          };\n          document.addEventListener(\"click\", onClickDocument);\n        } else {\n          // Log any other playback errors with console.error\n          console.error(`HoverVideoPlayer: ${error.message}`);\n        }\n      });\n    }\n  }, [isYouTube, playbackRangeStart]);\n\n  // Effect attempts to start playing the video if the user is hovering over the hover target\n  // and the video is loaded enough to be played\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (isHovering && !isLoading && !isPlaying) {\n      if (\n        nextVideoStartTimeRef.current !== null &&\n        videoElement.currentTime !== nextVideoStartTimeRef.current\n      ) {\n        videoElement.currentTime = nextVideoStartTimeRef.current;\n      }\n\n      if (playbackStartDelay) {\n        playTimeoutRef.current = window.setTimeout(\n          playVideo,\n          playbackStartDelay\n        );\n      } else {\n        playVideo();\n      }\n    }\n  }, [isHovering, isLoading, isPlaying, playVideo, playbackStartDelay]);\n\n  // Effect pauses the video if the user is no longer hovering over the hover target\n  // and the video is currently playing\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (!isHovering && (isPlaying || isLoading)) {\n      const pauseVideo = () => {\n        if (isYouTube) {\n          playerRef.current?.getInternalPlayer().pauseVideo();\n        } else {\n          videoElement.pause();\n        }\n\n        // Performing post-save cleanup tasks in here rather than the onPause listener\n        // because onPause can also be called when the video reaches the end of a playback range\n        // and it's just simpler to deal with that separately\n        if (restartOnPaused) {\n          if (isYouTube) {\n            playerRef.current?.seekTo(playbackRangeStart || 0);\n          } else {\n            videoElement.currentTime = playbackRangeStart || 0;\n          }\n        }\n        nextVideoStartTimeRef.current = isYouTube\n          ? playerRef.current?.getCurrentTime()!\n          : videoElement.currentTime;\n      };\n\n      if (shouldWaitForOverlayTransitionBeforePausing) {\n        // If we have a paused overlay, the player should wait\n        // for the overlay(s) to finish transitioning back in before we\n        // pause the video\n        pauseTimeoutRef.current = window.setTimeout(\n          pauseVideo,\n          overlayTransitionDuration\n        );\n      } else {\n        pauseVideo();\n      }\n    }\n  }, [\n    isHovering,\n    isLoading,\n    isPlaying,\n    overlayTransitionDuration,\n    playbackRangeStart,\n    restartOnPaused,\n    shouldWaitForOverlayTransitionBeforePausing,\n    isYouTube,\n  ]);\n\n  // Effect cancels any pending timeouts when the component unmounts\n  useEffect(() => () => cancelTimeouts(), [cancelTimeouts]);\n\n  // Keeping hover callbacks as refs because we want to be able to access them from within our\n  // onHoverStart and onHoverEnd event listeners without needing to re-run the\n  // event setup effect every time they change\n  const onHoverStartCallbackRef = useRef<typeof onHoverStart>();\n  onHoverStartCallbackRef.current = onHoverStart;\n\n  const onHoverEndCallbackRef = useRef<typeof onHoverEnd>();\n  onHoverEndCallbackRef.current = onHoverEnd;\n\n  // Effect sets up event listeners for hover events on hover target\n  useEffect(() => {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling || !hoverTargetElement) return undefined;\n\n    const onHoverStart = () => {\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      onHoverStartCallbackRef.current?.();\n    };\n    const onHoverEnd = () => {\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      onHoverEndCallbackRef.current?.();\n    };\n\n    // Mouse events\n    hoverTargetElement.addEventListener(\"mouseenter\", onHoverStart);\n    hoverTargetElement.addEventListener(\"mouseleave\", onHoverEnd);\n\n    // Focus/blur\n    hoverTargetElement.addEventListener(\"focus\", onHoverStart);\n    hoverTargetElement.addEventListener(\"blur\", onHoverEnd);\n\n    // Touch events\n    const touchStartListenerOptions = { passive: true };\n\n    hoverTargetElement.addEventListener(\n      \"touchstart\",\n      onHoverStart,\n      touchStartListenerOptions\n    );\n    // Event listener pauses the video when the user touches somewhere outside of the player\n    const onWindowTouchStart = (event: TouchEvent) => {\n      if (\n        !(event.target instanceof Node) ||\n        !hoverTargetElement.contains(event.target)\n      ) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener(\n      \"touchstart\",\n      onWindowTouchStart,\n      touchStartListenerOptions\n    );\n\n    // Return a cleanup function that removes all event listeners\n    return () => {\n      hoverTargetElement.removeEventListener(\"mouseenter\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"mouseleave\", onHoverEnd);\n      hoverTargetElement.removeEventListener(\"focus\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"blur\", onHoverEnd);\n      hoverTargetElement.removeEventListener(\"touchstart\", onHoverStart);\n      window.removeEventListener(\"touchstart\", onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetElement]);\n\n  // Defaulting the ref to false rather than the initial value of the focused prop because\n  // if focused is true initially, we want to run the effect, but if it's false, we don't\n  const previousFocusedRef = useRef<boolean>(false);\n\n  // Effect dispatches hover start/end events on the target element when the focused prop changes\n  useEffect(() => {\n    if (!hoverTargetElement) return;\n\n    if (previousFocusedRef.current !== focused) {\n      previousFocusedRef.current = focused;\n\n      if (focused) {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      } else {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      }\n    }\n  }, [hoverTargetElement, focused]);\n\n  const currentVideoSrc = useRef(videoSrc);\n  let shouldReloadVideoSrc = false;\n  if (videoSrc !== currentVideoSrc.current && !isHovering && !isPlaying) {\n    currentVideoSrc.current = videoSrc;\n    shouldReloadVideoSrc = true;\n  }\n\n  const hasStringSrc = typeof currentVideoSrc.current === \"string\";\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (shouldReloadVideoSrc) {\n      // If the video element doesn't have a loaded source or the source has changed since the\n      // last time we played the video, make sure to force the video to load the most up-to-date sources\n      videoElement.load();\n      // Reset the next start time to the start of the video\n      nextVideoStartTimeRef.current = playbackRangeStart || 0;\n    }\n  }, [playbackRangeStart, shouldReloadVideoSrc]);\n\n  // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.\n  // We will remove the video's <source> tags in this render and then call video.load() in an effect to\n  // fully unload the video\n  const shouldUnloadVideo = unloadVideoOnPaused && !isHovering && !isPlaying;\n\n  useEffect(() => {\n    if (shouldUnloadVideo) {\n      // Re-load the video with the sources removed so we unload everything from memory\n      videoRef.current?.load();\n    }\n  }, [shouldUnloadVideo]);\n\n  const shouldShowLoadingOverlay = isHovering && !isPlaying;\n  // Show a paused overlay when the user isn't hovering or when the user is hovering\n  // but the video is still loading\n  const shouldShowPausedOverlay = !isHovering || (isHovering && !isPlaying);\n\n  const isUsingPlaybackRange =\n    playbackRangeStart !== null || playbackRangeEnd !== null;\n\n  const hasLoadingOverlay = Boolean(loadingOverlay);\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        [overlayTransitionDurationVar as string]: `${overlayTransitionDuration}ms`,\n        ...containerSizingStyles[sizingMode],\n        position: \"relative\",\n        ...style,\n      }}\n      {...spreadableProps}\n    >\n      {hasPausedOverlay ? (\n        <div\n          style={{\n            ...pausedOverlayWrapperSizingStyles[sizingMode],\n            zIndex: 1,\n            ...(shouldShowPausedOverlay\n              ? visibleOverlayStyles\n              : hiddenOverlayStyles),\n            ...pausedOverlayWrapperStyle,\n          }}\n          className={pausedOverlayWrapperClassName}\n        >\n          {pausedOverlay}\n        </div>\n      ) : null}\n      {hasLoadingOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 2,\n            transitionDelay: loadingStateTimeout\n              ? `${loadingStateTimeout}ms`\n              : undefined,\n            ...(shouldShowLoadingOverlay\n              ? visibleOverlayStyles\n              : hiddenOverlayStyles),\n            ...loadingOverlayWrapperStyle,\n          }}\n          className={loadingOverlayWrapperClassName}\n        >\n          {loadingOverlay}\n        </div>\n      ) : null}\n      {hasHoverOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 3,\n            // Show the hover overlay when the player is hovered/playing\n            ...(isHovering ? visibleOverlayStyles : hiddenOverlayStyles),\n            ...hoverOverlayWrapperStyle,\n          }}\n          className={hoverOverlayWrapperClassName}\n        >\n          {hoverOverlay}\n        </div>\n      ) : null}\n      {isYouTube ? (\n        <ReactPlayer\n          ref={playerRef}\n          url={videoSrc as string}\n          width=\"100%\"\n          height=\"100%\"\n          playing={isPlaying}\n          muted={muted}\n          volume={volume}\n          loop={loop}\n          onReady={() => setIsLoading(false)}\n          onBuffer={() => setIsLoading(true)}\n          onBufferEnd={() => setIsLoading(false)}\n          config={{ playerVars: { controls: controls ? 1 : 0 } }}\n        />\n      ) : (\n        // eslint-disable-next-line jsx-a11y/media-has-caption\n        <video\n          src={\n            hasStringSrc && !shouldUnloadVideo\n              ? (currentVideoSrc.current as string)\n              : undefined\n          }\n          // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;\n          // in that case, we will manually implement this behavior\n          loop={isUsingPlaybackRange ? false : loop}\n          playsInline\n          preload={preload}\n          crossOrigin={crossOrigin}\n          ref={videoRef}\n          style={{\n            ...videoSizingStyles[sizingMode],\n            objectFit: \"cover\",\n            ...videoStyle,\n          }}\n          controls={controls}\n          controlsList={controlsList}\n          className={videoClassName}\n          id={videoId}\n          onPlaying={() => setIsPlaying(true)}\n          onPause={() => setIsPlaying(false)}\n          onEnded={() => setIsPlaying(false)}\n          // Update state when the video starts loading\n          onLoadStart={() => setIsLoading(true)}\n          // Update that we're no longer loading when the video has suspended loading data\n          onSuspend={() => setIsLoading(false)}\n          // Update that we are loading if the video is waiting for data to continue playing\n          onWaiting={() => setIsLoading(true)}\n          onLoadedData={() => {\n            // As video data is loaded, check if we've loaded enough data to start playing the video\n            // and update state accordingly\n            setIsLoading(\n              (videoRef.current?.readyState || 0) <\n                HTMLMediaElement.HAVE_ENOUGH_DATA\n            );\n          }}\n          onAbort={() => {\n            // If loading is aborted, update state\n            setIsLoading(false);\n          }}\n          onTimeUpdate={\n            // If there's a playback range set, the traditional `loop` video prop won't work correctly so\n            // we'll need watch the video's time as it plays and manually keep it within the bounds of the range\n            isUsingPlaybackRange\n              ? () => {\n                  const videoElement = videoRef.current;\n                  if (!videoElement) return;\n\n                  const maxVideoTime =\n                    playbackRangeEnd || videoElement.duration;\n                  const minVideoTime = playbackRangeStart || 0;\n\n                  const { currentTime } = videoElement;\n\n                  if (loop && currentTime >= maxVideoTime) {\n                    // If the video should loop and is >= the max video time,\n                    // loop it back around to the start\n                    const startTime = playbackRangeStart || 0;\n                    videoElement.currentTime = startTime;\n\n                    // If the video is paused but the user is still hovering,\n                    // meaning it should continue to play, call play() to keep it going\n                    if (\n                      isHovering &&\n                      (videoElement.paused || videoElement.ended)\n                    ) {\n                      playVideo();\n                    }\n                  } else if (currentTime > maxVideoTime) {\n                    // If the video shouldn't loop but we've exceeded the max video time,\n                    // clamp it to the max time and pause it\n                    videoElement.pause();\n                    videoElement.currentTime = maxVideoTime;\n                  } else if (currentTime < minVideoTime) {\n                    // If the video's time somehow ended up before the min video time,\n                    // clamp it to the min time\n                    videoElement.currentTime = minVideoTime;\n                  }\n                }\n              : undefined\n          }\n        >\n          {shouldUnloadVideo || hasStringSrc ? null : currentVideoSrc.current}\n          {videoCaptions}\n        </video>\n      )}\n    </div>\n  );\n}\n", "import React from 'react';\n\ninterface SizingModeStyle {\n  video: React.CSSProperties | null;\n  overlay: React.CSSProperties | null;\n  container: React.CSSProperties | null;\n  manual: React.CSSProperties | null;\n}\n\n// CSS styles to make some contents in the player expand to fill the container\nexport const expandToFillContainerStyle: React.CSSProperties = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n};\n\nconst containerMatchContentDimensionsStyle: React.CSSProperties = {\n  display: 'inline-block',\n};\n\nexport const containerSizingStyles: SizingModeStyle = {\n  video: containerMatchContentDimensionsStyle,\n  overlay: containerMatchContentDimensionsStyle,\n  container: null,\n  manual: null,\n};\n\n// Styles to apply to the paused overlay wrapper for each sizing mode\nexport const pausedOverlayWrapperSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative',\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null,\n};\n\n// Styles to apply to the video element for each sizing mode\nexport const videoSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%',\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null,\n};\n\nexport const overlayTransitionDurationVar = \"--hvp-overlay-transition-duration\";\n\nexport const visibleOverlayStyles: React.CSSProperties = {\n  visibility: 'visible',\n  opacity: 1,\n  transitionProperty: 'opacity',\n  transitionDuration: `var(${overlayTransitionDurationVar})`,\n};\n\nexport const hiddenOverlayStyles: React.CSSProperties = {\n  visibility: 'hidden',\n  opacity: 0,\n  transitionProperty: 'opacity, visibility',\n  transitionDuration: `var(${overlayTransitionDurationVar}), 0s`,\n  transitionDelay: `0s, var(${overlayTransitionDurationVar})`,\n};\n"],
  "mappings": "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",
  "names": ["onHoverStart", "onHoverEnd", "_a", "_b"]
}
